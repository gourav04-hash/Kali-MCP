#!/usr/bin/env python3
"""
Kali Security Tools MCP Server - Enhanced Version
Web penetration testing tools for educational purposes with improved security
"""
import os
import sys
import logging
import subprocess
import re
import json
import hashlib
import ipaddress
import time
from pathlib import Path
from datetime import datetime, timedelta
from collections import defaultdict
from typing import Optional, Tuple, List
from mcp.server.fastmcp import FastMCP

# Configure logging to stderr
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger("kali-security-server")

# Initialize MCP server
mcp = FastMCP("kali-security")

# ===== CONFIGURATION =====
MAX_OUTPUT_LENGTH = 10000
MAX_TARGET_LENGTH = 255
CACHE_DIR = Path("/tmp/scan_cache")
CACHE_TTL = 3600  # 1 hour
AUDIT_LOG = Path("/var/log/mcp_audit.log")

# Rate limiting
MAX_SCANS_PER_HOUR = 10
scan_history = defaultdict(list)

# Timeout configuration
TOOL_TIMEOUTS = {
    "nmap": int(os.getenv("NMAP_TIMEOUT", "600")),
    "nikto": int(os.getenv("NIKTO_TIMEOUT", "600")),
    "sqlmap": int(os.getenv("SQLMAP_TIMEOUT", "600")),
    "wpscan": int(os.getenv("WPSCAN_TIMEOUT", "600")),
    "dirb": int(os.getenv("DIRB_TIMEOUT", "600")),
    "default": int(os.getenv("DEFAULT_TIMEOUT", "300"))
}

# Blocked IP ranges (private networks)
BLOCKED_RANGES = [
    ipaddress.ip_network('10.0.0.0/8'),
    ipaddress.ip_network('172.16.0.0/12'),
    ipaddress.ip_network('192.168.0.0/16'),
    ipaddress.ip_network('127.0.0.0/8'),
    ipaddress.ip_network('169.254.0.0/16'),  # Link-local
]

# Allowed command options (whitelist approach)
ALLOWED_NMAP_OPTIONS = {
    '-sV', '-sC', '-A', '-F', '-p', '-Pn', '-T1', '-T2', '-T3', '-T4', '-T5',
    '-v', '-vv', '-O', '--script', '--top-ports', '-sU', '-sT', '-sS'
}

ALLOWED_CUSTOM_COMMANDS = {
    'ls', 'pwd', 'whoami', 'id', 'uname', 'cat', 'grep', 'find', 'head', 'tail'
}

# Create cache directory
CACHE_DIR.mkdir(exist_ok=True, parents=True)

# ===== UTILITY FUNCTIONS =====

def check_rate_limit(tool_name: str) -> bool:
    """Check if rate limit exceeded for a tool."""
    now = datetime.now()
    hour_ago = now - timedelta(hours=1)
    
    # Clean old entries
    scan_history[tool_name] = [
        t for t in scan_history[tool_name] if t > hour_ago
    ]
    
    if len(scan_history[tool_name]) >= MAX_SCANS_PER_HOUR:
        return False
    
    scan_history[tool_name].append(now)
    return True


def log_audit_event(tool_name: str, target: str, success: bool, details: str = ""):
    """Log scan activity to audit file."""
    try:
        audit_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "tool": tool_name,
            "target": target,
            "success": success,
            "details": details
        }
        
        with open(AUDIT_LOG, "a") as f:
            f.write(json.dumps(audit_entry) + "\n")
    except Exception as e:
        logger.error(f"Failed to write audit log: {e}")


def get_cache_key(tool: str, target: str, options: str = "") -> str:
    """Generate cache key for scan results."""
    data = f"{tool}:{target}:{options}"
    return hashlib.sha256(data.encode()).hexdigest()


def get_cached_result(cache_key: str) -> Optional[str]:
    """Retrieve cached scan result if valid."""
    cache_file = CACHE_DIR / f"{cache_key}.json"
    
    if not cache_file.exists():
        return None
    
    try:
        with open(cache_file) as f:
            cached = json.load(f)
        
        # Check TTL
        age = time.time() - cached["timestamp"]
        if age > CACHE_TTL:
            cache_file.unlink()
            return None
        
        logger.info(f"Cache hit for {cache_key[:8]}...")
        return cached["result"]
    except Exception as e:
        logger.warning(f"Cache read error: {e}")
        return None


def cache_result(cache_key: str, result: str):
    """Cache scan result."""
    try:
        cache_file = CACHE_DIR / f"{cache_key}.json"
        with open(cache_file, 'w') as f:
            json.dump({
                "timestamp": time.time(),
                "result": result
            }, f)
    except Exception as e:
        logger.warning(f"Cache write error: {e}")


def is_target_allowed(target: str) -> Tuple[bool, str]:
    """Check if target is allowed (not private/localhost)."""
    try:
        ip = ipaddress.ip_address(target)
        for blocked_range in BLOCKED_RANGES:
            if ip in blocked_range:
                return False, f"Target {target} is in blocked range {blocked_range}"
        return True, ""
    except ValueError:
        # Not an IP address, assume it's a domain (allowed)
        if target.lower() in ['localhost', '0.0.0.0']:
            return False, "Localhost scanning is not allowed"
        return True, ""


def sanitize_output(output: str) -> str:
    """Remove sensitive patterns from output."""
    # Remove potential credentials
    output = re.sub(r'password[:\s=]+[\w\S]+', 'password: [REDACTED]', output, flags=re.I)
    output = re.sub(r'api[_-]?key[:\s=]+[\w\S]+', 'api_key: [REDACTED]', output, flags=re.I)
    output = re.sub(r'token[:\s=]+[\w\S]+', 'token: [REDACTED]', output, flags=re.I)
    
    # Remove absolute paths that might leak system info
    output = re.sub(r'/home/[\w-]+/', '/home/[USER]/', output)
    
    return output


def validate_target(target: str, target_type: str = "ip") -> str:
    """Validate and sanitize target based on expected format."""
    target = target.strip()
    
    # Length check
    if len(target) > MAX_TARGET_LENGTH:
        raise ValueError(f"Target too long (max {MAX_TARGET_LENGTH} characters)")
    
    # Remove dangerous characters
    if any(c in target for c in [';', '&', '|', '`', '$', '\n', '\r', '\0']):
        raise ValueError("Invalid characters detected in target")
    
    # Type-specific validation
    if target_type == "ip":
        # Try to parse as IP address
        try:
            ipaddress.ip_address(target)
        except ValueError:
            # Not an IP, might be domain - validate domain format
            if not re.match(r'^[a-zA-Z0-9][a-zA-Z0-9-_.]*[a-zA-Z0-9]$', target):
                raise ValueError("Invalid IP address or domain format")
    
    elif target_type == "url":
        # Validate URL format
        if not re.match(r'^https?://[a-zA-Z0-9][a-zA-Z0-9-_.:/]*[a-zA-Z0-9]/?.*$', target):
            raise ValueError("Invalid URL format")
        
        # Extract hostname and validate
        hostname = re.search(r'https?://([^/:]+)', target)
        if hostname:
            try:
                ipaddress.ip_address(hostname.group(1))
            except ValueError:
                pass  # It's a domain, which is fine
    
    # Check if target is allowed
    allowed, reason = is_target_allowed(target.split('/')[0].split(':')[0])
    if not allowed:
        raise ValueError(reason)
    
    return target


def parse_nmap_options(options: str) -> List[str]:
    """Validate and parse nmap options."""
    if not options.strip():
        return ["-sV", "-sC"]
    
    parts = options.split()
    validated = []
    
    i = 0
    while i < len(parts):
        opt = parts[i]
        base_opt = opt.split('=')[0]
        
        if base_opt not in ALLOWED_NMAP_OPTIONS:
            raise ValueError(f"Nmap option '{opt}' is not allowed. Allowed options: {', '.join(sorted(ALLOWED_NMAP_OPTIONS))}")
        
        validated.append(opt)
        
        # Handle options with values (not using =)
        if base_opt in ['-p', '--script', '--top-ports'] and '=' not in opt:
            if i + 1 < len(parts) and not parts[i + 1].startswith('-'):
                validated.append(parts[i + 1])
                i += 1
        i += 1
    
    return validated


def run_command(command: List[str], timeout: int = 300) -> Tuple[str, int]:
    """Execute command safely and return formatted output."""
    try:
        logger.info(f"Executing command: {' '.join(command[:3])}...")
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            timeout=timeout,
            env={'PATH': os.environ.get('PATH', '/usr/bin:/bin')}
        )
        
        output = result.stdout if result.returncode == 0 else result.stderr
        
        # Sanitize output
        output = sanitize_output(output)
        
        if len(output) > MAX_OUTPUT_LENGTH:
            output = output[:MAX_OUTPUT_LENGTH] + "\n\n... (output truncated)"
        
        return output, result.returncode
    except subprocess.TimeoutExpired:
        return f"Command timed out after {timeout} seconds", 1
    except Exception as e:
        logger.error(f"Command execution error: {e}")
        return str(e), 1


def format_output(title: str, output: str, returncode: int) -> str:
    """Format command output with visual indicators."""
    status = "SUCCESS - Scan Complete" if returncode == 0 else "COMPLETED WITH WARNINGS"
    separator = "=" * 60
    return f"{separator}\n{status}\n{separator}\n\n{title}\n\n{output}"


# ===== MCP TOOLS =====

@mcp.tool()
async def nmap_scan(target: str = "", options: str = "-sV -sC") -> str:
    """
    Perform network port scan using nmap with version detection and default scripts.
    
    Args:
        target: IP address or domain to scan (e.g., 'scanme.nmap.org')
        options: Nmap options (default: '-sV -sC')
    
    Returns:
        Scan results with open ports, services, and versions
    """
    if not target.strip():
        return "ERROR: Target is required (e.g., 'scanme.nmap.org' or '8.8.8.8')"
    
    # Check rate limit
    if not check_rate_limit("nmap"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        # Validate target
        target = validate_target(target, "ip")
        
        # Parse and validate options
        parsed_options = parse_nmap_options(options)
        
        # Check cache
        cache_key = get_cache_key("nmap", target, options)
        cached = get_cached_result(cache_key)
        if cached:
            log_audit_event("nmap", target, True, "cache_hit")
            return f"[CACHED RESULT]\n\n{cached}"
        
        # Execute scan
        logger.info(f"Running nmap scan on {target}")
        command = ["nmap"] + parsed_options + [target]
        output, returncode = run_command(command, timeout=300)
        
        log_audit_event("git_clone", repo_url, returncode == 0, f"destination: {destination}")
        
        return format_output(f"Git Clone: {repo_url}", output, returncode)
        
    except ValueError as e:
        log_audit_event("git_clone", repo_url, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Git clone error: {e}", exc_info=True)
        log_audit_event("git_clone", repo_url, False, f"exception: {str(e)}")
        return f"ERROR: Clone failed - {str(e)}"


@mcp.tool()
async def git_pull(repo_path: str = "/app") -> str:
    """
    Update a git repository by pulling latest changes.
    
    Args:
        repo_path: Repository path (default: '/app')
    
    Returns:
        Pull operation result
    """
    try:
        repo_path = repo_path.strip() or "/app"
        
        # Validate path
        if not re.match(r'^/[a-zA-Z0-9_/-]+command(command, timeout=TOOL_TIMEOUTS["nmap"])
        
        result = format_output(f"Nmap Scan: {target}", output, returncode)
        
        # Cache result
        cache_result(cache_key, result)
        
        # Audit log
        log_audit_event("nmap", target, returncode == 0, f"options: {options}")
        
        return result
        
    except ValueError as e:
        log_audit_event("nmap", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Nmap scan error: {e}", exc_info=True)
        log_audit_event("nmap", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def nikto_scan(target: str = "", port: str = "80") -> str:
    """
    Perform web server vulnerability scan using Nikto.
    
    Args:
        target: Target URL (e.g., 'http://example.com')
        port: Port number (default: '80')
    
    Returns:
        Web server vulnerability scan results
    """
    if not target.strip():
        return "ERROR: Target URL is required (e.g., 'http://example.com')"
    
    if not check_rate_limit("nikto"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        target = validate_target(target, "url")
        
        # Validate port
        if not port.isdigit() or not (1 <= int(port) <= 65535):
            raise ValueError("Port must be a number between 1 and 65535")
        
        # Check cache
        cache_key = get_cache_key("nikto", target, port)
        cached = get_cached_result(cache_key)
        if cached:
            log_audit_event("nikto", target, True, "cache_hit")
            return f"[CACHED RESULT]\n\n{cached}"
        
        logger.info(f"Running Nikto scan on {target}:{port}")
        command = ["nikto", "-h", target, "-p", port]
        output, returncode = run_command(command, timeout=TOOL_TIMEOUTS["nikto"])
        
        result = format_output(f"Nikto Web Scan: {target}:{port}", output, returncode)
        
        cache_result(cache_key, result)
        log_audit_event("nikto", target, returncode == 0, f"port: {port}")
        
        return result
        
    except ValueError as e:
        log_audit_event("nikto", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Nikto scan error: {e}", exc_info=True)
        log_audit_event("nikto", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def dirb_scan(target: str = "", wordlist: str = "/usr/share/dirb/wordlists/common.txt") -> str:
    """
    Perform directory brute force scan using DIRB to find hidden web paths.
    
    Args:
        target: Target URL (e.g., 'http://example.com')
        wordlist: Path to wordlist file (default: common.txt)
    
    Returns:
        Directory enumeration results
    """
    if not target.strip():
        return "ERROR: Target URL is required (e.g., 'http://example.com')"
    
    if not check_rate_limit("dirb"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        target = validate_target(target, "url")
        
        # Validate wordlist path
        if not Path(wordlist).exists():
            raise ValueError(f"Wordlist not found: {wordlist}")
        
        # Check cache
        cache_key = get_cache_key("dirb", target, wordlist)
        cached = get_cached_result(cache_key)
        if cached:
            log_audit_event("dirb", target, True, "cache_hit")
            return f"[CACHED RESULT]\n\n{cached}"
        
        logger.info(f"Running DIRB scan on {target}")
        command = ["dirb", target, wordlist, "-S"]
        output, returncode = run_command(command, timeout=TOOL_TIMEOUTS["dirb"])
        
        result = format_output(f"DIRB Directory Scan: {target}", output, returncode)
        
        cache_result(cache_key, result)
        log_audit_event("dirb", target, returncode == 0, f"wordlist: {wordlist}")
        
        return result
        
    except ValueError as e:
        log_audit_event("dirb", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"DIRB scan error: {e}", exc_info=True)
        log_audit_event("dirb", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def wpscan_scan(target: str = "", enumerate: str = "p,t,u") -> str:
    """
    Perform WordPress vulnerability scan using WPScan.
    
    Args:
        target: WordPress site URL (e.g., 'http://example.com/wordpress')
        enumerate: What to enumerate - p=plugins, t=themes, u=users (default: 'p,t,u')
    
    Returns:
        WordPress vulnerability scan results
    """
    if not target.strip():
        return "ERROR: Target WordPress URL is required (e.g., 'http://example.com/wordpress')"
    
    if not check_rate_limit("wpscan"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        target = validate_target(target, "url")
        
        # Validate enumerate options
        valid_opts = {'p', 't', 'u', 'vp', 'vt', 'tt', 'cb', 'dbe', 'm'}
        enum_parts = [e.strip() for e in enumerate.split(',')]
        for part in enum_parts:
            if part not in valid_opts:
                raise ValueError(f"Invalid enumerate option: {part}. Valid: {', '.join(valid_opts)}")
        
        # Check cache
        cache_key = get_cache_key("wpscan", target, enumerate)
        cached = get_cached_result(cache_key)
        if cached:
            log_audit_event("wpscan", target, True, "cache_hit")
            return f"[CACHED RESULT]\n\n{cached}"
        
        logger.info(f"Running WPScan on {target}")
        command = ["wpscan", "--url", target, "--enumerate", enumerate, "--no-banner"]
        output, returncode = run_command(command, timeout=TOOL_TIMEOUTS["wpscan"])
        
        result = format_output(f"WPScan WordPress Scan: {target}", output, returncode)
        
        cache_result(cache_key, result)
        log_audit_event("wpscan", target, returncode == 0, f"enumerate: {enumerate}")
        
        return result
        
    except ValueError as e:
        log_audit_event("wpscan", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"WPScan error: {e}", exc_info=True)
        log_audit_event("wpscan", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def sqlmap_scan(target: str = "", data: str = "") -> str:
    """
    Perform SQL injection testing using sqlmap.
    
    Args:
        target: Target URL with parameter (e.g., 'http://example.com/page.php?id=1')
        data: POST data for testing (optional)
    
    Returns:
        SQL injection test results
    """
    if not target.strip():
        return "ERROR: Target URL is required (e.g., 'http://example.com/page.php?id=1')"
    
    if not check_rate_limit("sqlmap"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        target = validate_target(target, "url")
        
        # Check cache
        cache_key = get_cache_key("sqlmap", target, data)
        cached = get_cached_result(cache_key)
        if cached:
            log_audit_event("sqlmap", target, True, "cache_hit")
            return f"[CACHED RESULT]\n\n{cached}"
        
        logger.info(f"Running SQLMap on {target}")
        command = ["sqlmap", "-u", target, "--batch", "--banner"]
        
        if data.strip():
            # Basic validation for POST data
            if any(c in data for c in [';', '|', '&', '`']):
                raise ValueError("Invalid characters in POST data")
            command.extend(["--data", data])
        
        output, returncode = run_command(command, timeout=TOOL_TIMEOUTS["sqlmap"])
        
        result = format_output(f"SQLMap SQL Injection Test: {target}", output, returncode)
        
        cache_result(cache_key, result)
        log_audit_event("sqlmap", target, returncode == 0, f"has_data: {bool(data)}")
        
        return result
        
    except ValueError as e:
        log_audit_event("sqlmap", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"SQLMap error: {e}", exc_info=True)
        log_audit_event("sqlmap", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def searchsploit_query(keyword: str = "") -> str:
    """
    Search exploit database using searchsploit for known vulnerabilities.
    
    Args:
        keyword: Search term (e.g., 'apache 2.4', 'wordpress 5.0')
    
    Returns:
        List of known exploits matching the keyword
    """
    if not keyword.strip():
        return "ERROR: Search keyword is required (e.g., 'apache 2.4', 'wordpress 5.0')"
    
    if not check_rate_limit("searchsploit"):
        return "ERROR: Rate limit exceeded. Maximum 10 searches per hour."
    
    try:
        # Basic sanitization
        keyword = keyword.strip()
        if len(keyword) > 100:
            raise ValueError("Keyword too long (max 100 characters)")
        
        if any(c in keyword for c in [';', '|', '&', '`', '$']):
            raise ValueError("Invalid characters in keyword")
        
        logger.info(f"Searching exploits for: {keyword}")
        command = ["searchsploit", keyword]
        output, returncode = run_command(command, timeout=60)
        
        log_audit_event("searchsploit", keyword, returncode == 0, "")
        
        return format_output(f"Exploit Database Search: {keyword}", output, returncode)
        
    except ValueError as e:
        log_audit_event("searchsploit", keyword, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Searchsploit error: {e}", exc_info=True)
        log_audit_event("searchsploit", keyword, False, f"exception: {str(e)}")
        return f"ERROR: Search failed - {str(e)}"


@mcp.tool()
async def quick_recon(target: str = "") -> str:
    """
    Perform quick reconnaissance combining fast nmap scan.
    
    Args:
        target: IP address or domain (e.g., 'scanme.nmap.org')
    
    Returns:
        Quick reconnaissance results
    """
    if not target.strip():
        return "ERROR: Target is required (e.g., 'scanme.nmap.org' or '8.8.8.8')"
    
    if not check_rate_limit("quick_recon"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        target = validate_target(target, "ip")
        
        logger.info(f"Running quick recon on {target}")
        
        command = ["nmap", "-F", "-sV", target]
        output, returncode = run_command(command, timeout=300)
        
        result = f"Quick Reconnaissance Results\n{'=' * 60}\n\nTarget: {target}\n\n{output}"
        
        log_audit_event("quick_recon", target, returncode == 0, "")
        
        return result
        
    except ValueError as e:
        log_audit_event("quick_recon", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Quick recon error: {e}", exc_info=True)
        log_audit_event("quick_recon", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def apt_install(package: str = "") -> str:
    """
    Install a package using apt package manager.
    
    Args:
        package: Package name (e.g., 'metasploit-framework', 'burpsuite')
    
    Returns:
        Installation result
    """
    if not package.strip():
        return "ERROR: Package name is required (e.g., 'metasploit-framework')"
    
    try:
        # Validate package name (alphanumeric, dash, underscore only)
        if not re.match(r'^[a-zA-Z0-9_-]+$', package):
            raise ValueError("Invalid package name. Use only letters, numbers, dash, and underscore")
        
        if len(package) > 100:
            raise ValueError("Package name too long")
        
        logger.info(f"Installing package: {package}")
        
        # Update package list
        update_cmd = ["apt-get", "update"]
        update_output, update_ret = run_command(update_cmd, timeout=120)
        
        if update_ret != 0:
            return f"ERROR: Failed to update package list:\n{update_output}"
        
        # Install package
        install_cmd = ["apt-get", "install", "-y", package]
        install_output, install_ret = run_command(install_cmd, timeout=600)
        
        log_audit_event("apt_install", package, install_ret == 0, "")
        
        if install_ret == 0:
            return f"SUCCESS - Package Installed\n\nPackage '{package}' has been successfully installed.\n\n{install_output}"
        else:
            return f"ERROR: Failed to install package '{package}':\n{install_output}"
            
    except ValueError as e:
        log_audit_event("apt_install", package, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Apt install error: {e}", exc_info=True)
        log_audit_event("apt_install", package, False, f"exception: {str(e)}")
        return f"ERROR: Installation failed - {str(e)}"


@mcp.tool()
async def apt_search(keyword: str = "") -> str:
    """
    Search for available packages in apt repositories.
    
    Args:
        keyword: Search term (e.g., 'wireless', 'web scanner')
    
    Returns:
        List of matching packages
    """
    if not keyword.strip():
        return "ERROR: Search keyword is required"
    
    try:
        keyword = keyword.strip()
        if len(keyword) > 100:
            raise ValueError("Keyword too long")
        
        if not re.match(r'^[a-zA-Z0-9 _-]+$', keyword):
            raise ValueError("Invalid characters in keyword")
        
        logger.info(f"Searching for packages matching: {keyword}")
        command = ["apt-cache", "search", keyword]
        output, returncode = run_command(command, timeout=60)
        
        return format_output(f"Package Search Results: {keyword}", output, returncode)
        
    except ValueError as e:
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Apt search error: {e}", exc_info=True)
        return f"ERROR: Search failed - {str(e)}"


@mcp.tool()
async def git_clone(repo_url: str = "", destination: str = "") -> str:
    """
    Clone a git repository to the specified destination.
    
    Args:
        repo_url: Git repository URL (e.g., 'https://github.com/user/repo.git')
        destination: Target directory (optional)
    
    Returns:
        Clone operation result
    """
    if not repo_url.strip():
        return "ERROR: Repository URL is required (e.g., 'https://github.com/user/repo.git')"
    
    try:
        repo_url = repo_url.strip()
        
        # Validate URL format
        if not re.match(r'^https?://[a-zA-Z0-9][a-zA-Z0-9-_.:/]*[a-zA-Z0-9]/?.*\.git$', repo_url):
            raise ValueError("Invalid Git repository URL format (must be https:// or http:// and end with .git)")
        
        logger.info(f"Cloning repository: {repo_url}")
        
        command = ["git", "clone", repo_url]
        
        if destination.strip():
            # Validate destination path
            if not re.match(r'^[a-zA-Z0-9_/-]+$', destination):
                raise ValueError("Invalid destination path")
            command.append(destination)
        
        output, returncode = run_, repo_path):
            raise ValueError("Invalid repository path")
        
        if not Path(repo_path).exists():
            raise ValueError(f"Repository path does not exist: {repo_path}")
        
        logger.info(f"Pulling latest changes in: {repo_path}")
        command = ["git", "-C", repo_path, "pull"]
        output, returncode = run_command(command, timeout=120)
        
        log_audit_event("git_pull", repo_path, returncode == 0, "")
        
        return format_output(f"Git Pull: {repo_path}", output, returncode)
        
    except ValueError as e:
        log_audit_event("git_pull", repo_path, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Git pull error: {e}", exc_info=True)
        log_audit_event("git_pull", repo_path, False, f"exception: {str(e)}")
        return f"ERROR: Pull failed - {str(e)}"


@mcp.tool()
async def list_installed_tools() -> str:
    """
    List security tools currently installed in the container.
    
    Returns:
        List of installed security tools with their paths
    """
    logger.info("Listing installed security tools")
    
    tools_to_check = [
        "nmap", "nikto", "sqlmap", "wpscan", "dirb", "searchsploit",
        "metasploit-framework", "burpsuite", "john", "hydra", "aircrack-ng",
        "wireshark", "tcpdump", "netcat", "gobuster", "ffuf", "masscan",
        "enum4linux", "smbclient", "crackmapexec"
    ]
    
    results = []
    installed_count = 0
    
    for tool in tools_to_check:
        check_cmd = ["which", tool]
        output, returncode = run_command(check_cmd, timeout=5)
        
        if returncode == 0 and output.strip():
            results.append(f"[INSTALLED] {tool}: {output.strip()}")
            installed_count += 1
        else:
            results.append(f"[NOT FOUND] {tool}")
    
    summary = f"Installed Security Tools ({installed_count}/{len(tools_to_check)} found)"
    separator = "=" * 60
    
    return f"{separator}\n{summary}\n{separator}\n\n" + "\n".join(results)


@mcp.tool()
async def run_safe_command(command: str = "") -> str:
    """
    Execute a safe whitelisted shell command (read-only operations only).
    
    Args:
        command: Command to execute (must be from allowed list)
    
    Returns:
        Command output
    
    Note: Only safe read-only commands are allowed: ls, pwd, whoami, id, uname, cat, grep, find, head, tail
    """
    if not command.strip():
        return "ERROR: Command is required"
    
    try:
        command = command.strip()
        parts = command.split()
        
        if not parts:
            raise ValueError("Empty command")
        
        base_command = parts[0]
        
        # Check if command is in whitelist
        if base_command not in ALLOWED_CUSTOM_COMMANDS:
            return f"ERROR: Command '{base_command}' is not allowed.\n\nAllowed commands: {', '.join(sorted(ALLOWED_CUSTOM_COMMANDS))}\n\nThese are safe, read-only commands for system information."
        
        # Additional validation for dangerous patterns
        if any(pattern in command for pattern in ['>', '<', '|', ';', '&', '$(', '`']):
            raise ValueError("Command contains dangerous operators (>, <, |, ;, &, $(), `)")
        
        logger.info(f"Executing safe command: {command[:50]}...")
        
        result = subprocess.run(
            command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30
        )
        
        output = result.stdout if result.returncode == 0 else result.stderr
        output = sanitize_output(output)
        
        if len(output) > MAX_OUTPUT_LENGTH:
            output = output[:MAX_OUTPUT_LENGTH] + "\n\n... (output truncated)"
        
        log_audit_event("run_safe_command", command, result.returncode == 0, "")
        
        status = "SUCCESS" if result.returncode == 0 else "COMPLETED WITH ERRORS"
        return f"{status} - Safe Command\n\nCommand: {command}\n\n{output}"
        
    except ValueError as e:
        log_audit_event("run_safe_command", command, False, str(e))
        return f"ERROR: {str(e)}"
    except subprocess.TimeoutExpired:
        return "ERROR: Command timed out after 30 seconds"
    except Exception as e:
        logger.error(f"Command execution error: {e}", exc_info=True)
        log_audit_event("run_safe_command", command, False, f"exception: {str(e)}")
        return f"ERROR: Command failed - {str(e)}"


@mcp.tool()
async def get_scan_statistics() -> str:
    """
    Get statistics about scan usage and rate limits.
    
    Returns:
        Current scan statistics and remaining quota
    """
    now = datetime.now()
    hour_ago = now - timedelta(hours=1)
    
    stats = []
    stats.append("Scan Statistics (Last Hour)")
    stats.append("=" * 60)
    stats.append("")
    
    total_scans = 0
    for tool_name, timestamps in scan_history.items():
        recent = [t for t in timestamps if t > hour_ago]
        count = len(recent)
        total_scans += count
        remaining = MAX_SCANS_PER_HOUR - count
        
        if count > 0:
            stats.append(f"{tool_name}:")
            stats.append(f"  - Scans used: {count}/{MAX_SCANS_PER_HOUR}")
            stats.append(f"  - Remaining: {remaining}")
            stats.append("")
    
    if total_scans == 0:
        stats.append("No scans performed in the last hour.")
    else:
        stats.append(f"Total scans: {total_scans}")
    
    stats.append("")
    stats.append("Rate Limit: 10 scans per hour per tool")
    
    return "\n".join(stats)


@mcp.tool()
async def clear_cache() -> str:
    """
    Clear all cached scan results.
    
    Returns:
        Cache clearing result
    """
    try:
        cache_files = list(CACHE_DIR.glob("*.json"))
        count = len(cache_files)
        
        for cache_file in cache_files:
            cache_file.unlink()
        
        logger.info(f"Cleared {count} cached results")
        log_audit_event("clear_cache", "system", True, f"cleared {count} files")
        
        return f"SUCCESS - Cache Cleared\n\nRemoved {count} cached scan results."
        
    except Exception as e:
        logger.error(f"Cache clear error: {e}", exc_info=True)
        return f"ERROR: Failed to clear cache - {str(e)}"


# ===== SERVER STARTUP =====
if __name__ == "__main__":
    # Root check
    if os.geteuid() != 0:
        logger.error("ERROR: This server must run as root for security tools to work properly")
        logger.error("Please rebuild the Docker image or run the container with --user root")
        sys.exit(1)
    
    # Create audit log directory
    AUDIT_LOG.parent.mkdir(exist_ok=True, parents=True)
    
    logger.info("=" * 60)
    logger.info("Kali Security Tools MCP Server - Enhanced Version")
    logger.info("=" * 60)
    logger.info("Running as root user (required for network scanning tools)")
    logger.info(f"Cache directory: {CACHE_DIR}")
    logger.info(f"Audit log: {AUDIT_LOG}")
    logger.info(f"Rate limit: {MAX_SCANS_PER_HOUR} scans/hour per tool")
    logger.info("=" * 60)
    logger.warning("WARNING: EDUCATIONAL USE ONLY")
    logger.warning("Only scan systems you own or have written permission to test")
    logger.warning("Unauthorized scanning is ILLEGAL and can result in prosecution")
    logger.info("=" * 60)
    
    try:
        mcp.run(transport='stdio')
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
        sys.exit(1)command(command, timeout=TOOL_TIMEOUTS["nmap"])
        
        result = format_output(f"Nmap Scan: {target}", output, returncode)
        
        # Cache result
        cache_result(cache_key, result)
        
        # Audit log
        log_audit_event("nmap", target, returncode == 0, f"options: {options}")
        
        return result
        
    except ValueError as e:
        log_audit_event("nmap", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Nmap scan error: {e}", exc_info=True)
        log_audit_event("nmap", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def nikto_scan(target: str = "", port: str = "80") -> str:
    """
    Perform web server vulnerability scan using Nikto.
    
    Args:
        target: Target URL (e.g., 'http://example.com')
        port: Port number (default: '80')
    
    Returns:
        Web server vulnerability scan results
    """
    if not target.strip():
        return "ERROR: Target URL is required (e.g., 'http://example.com')"
    
    if not check_rate_limit("nikto"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        target = validate_target(target, "url")
        
        # Validate port
        if not port.isdigit() or not (1 <= int(port) <= 65535):
            raise ValueError("Port must be a number between 1 and 65535")
        
        # Check cache
        cache_key = get_cache_key("nikto", target, port)
        cached = get_cached_result(cache_key)
        if cached:
            log_audit_event("nikto", target, True, "cache_hit")
            return f"[CACHED RESULT]\n\n{cached}"
        
        logger.info(f"Running Nikto scan on {target}:{port}")
        command = ["nikto", "-h", target, "-p", port]
        output, returncode = run_command(command, timeout=TOOL_TIMEOUTS["nikto"])
        
        result = format_output(f"Nikto Web Scan: {target}:{port}", output, returncode)
        
        cache_result(cache_key, result)
        log_audit_event("nikto", target, returncode == 0, f"port: {port}")
        
        return result
        
    except ValueError as e:
        log_audit_event("nikto", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Nikto scan error: {e}", exc_info=True)
        log_audit_event("nikto", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def dirb_scan(target: str = "", wordlist: str = "/usr/share/dirb/wordlists/common.txt") -> str:
    """
    Perform directory brute force scan using DIRB to find hidden web paths.
    
    Args:
        target: Target URL (e.g., 'http://example.com')
        wordlist: Path to wordlist file (default: common.txt)
    
    Returns:
        Directory enumeration results
    """
    if not target.strip():
        return "ERROR: Target URL is required (e.g., 'http://example.com')"
    
    if not check_rate_limit("dirb"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        target = validate_target(target, "url")
        
        # Validate wordlist path
        if not Path(wordlist).exists():
            raise ValueError(f"Wordlist not found: {wordlist}")
        
        # Check cache
        cache_key = get_cache_key("dirb", target, wordlist)
        cached = get_cached_result(cache_key)
        if cached:
            log_audit_event("dirb", target, True, "cache_hit")
            return f"[CACHED RESULT]\n\n{cached}"
        
        logger.info(f"Running DIRB scan on {target}")
        command = ["dirb", target, wordlist, "-S"]
        output, returncode = run_command(command, timeout=TOOL_TIMEOUTS["dirb"])
        
        result = format_output(f"DIRB Directory Scan: {target}", output, returncode)
        
        cache_result(cache_key, result)
        log_audit_event("dirb", target, returncode == 0, f"wordlist: {wordlist}")
        
        return result
        
    except ValueError as e:
        log_audit_event("dirb", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"DIRB scan error: {e}", exc_info=True)
        log_audit_event("dirb", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def wpscan_scan(target: str = "", enumerate: str = "p,t,u") -> str:
    """
    Perform WordPress vulnerability scan using WPScan.
    
    Args:
        target: WordPress site URL (e.g., 'http://example.com/wordpress')
        enumerate: What to enumerate - p=plugins, t=themes, u=users (default: 'p,t,u')
    
    Returns:
        WordPress vulnerability scan results
    """
    if not target.strip():
        return "ERROR: Target WordPress URL is required (e.g., 'http://example.com/wordpress')"
    
    if not check_rate_limit("wpscan"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        target = validate_target(target, "url")
        
        # Validate enumerate options
        valid_opts = {'p', 't', 'u', 'vp', 'vt', 'tt', 'cb', 'dbe', 'm'}
        enum_parts = [e.strip() for e in enumerate.split(',')]
        for part in enum_parts:
            if part not in valid_opts:
                raise ValueError(f"Invalid enumerate option: {part}. Valid: {', '.join(valid_opts)}")
        
        # Check cache
        cache_key = get_cache_key("wpscan", target, enumerate)
        cached = get_cached_result(cache_key)
        if cached:
            log_audit_event("wpscan", target, True, "cache_hit")
            return f"[CACHED RESULT]\n\n{cached}"
        
        logger.info(f"Running WPScan on {target}")
        command = ["wpscan", "--url", target, "--enumerate", enumerate, "--no-banner"]
        output, returncode = run_command(command, timeout=TOOL_TIMEOUTS["wpscan"])
        
        result = format_output(f"WPScan WordPress Scan: {target}", output, returncode)
        
        cache_result(cache_key, result)
        log_audit_event("wpscan", target, returncode == 0, f"enumerate: {enumerate}")
        
        return result
        
    except ValueError as e:
        log_audit_event("wpscan", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"WPScan error: {e}", exc_info=True)
        log_audit_event("wpscan", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def sqlmap_scan(target: str = "", data: str = "") -> str:
    """
    Perform SQL injection testing using sqlmap.
    
    Args:
        target: Target URL with parameter (e.g., 'http://example.com/page.php?id=1')
        data: POST data for testing (optional)
    
    Returns:
        SQL injection test results
    """
    if not target.strip():
        return "ERROR: Target URL is required (e.g., 'http://example.com/page.php?id=1')"
    
    if not check_rate_limit("sqlmap"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        target = validate_target(target, "url")
        
        # Check cache
        cache_key = get_cache_key("sqlmap", target, data)
        cached = get_cached_result(cache_key)
        if cached:
            log_audit_event("sqlmap", target, True, "cache_hit")
            return f"[CACHED RESULT]\n\n{cached}"
        
        logger.info(f"Running SQLMap on {target}")
        command = ["sqlmap", "-u", target, "--batch", "--banner"]
        
        if data.strip():
            # Basic validation for POST data
            if any(c in data for c in [';', '|', '&', '`']):
                raise ValueError("Invalid characters in POST data")
            command.extend(["--data", data])
        
        output, returncode = run_command(command, timeout=TOOL_TIMEOUTS["sqlmap"])
        
        result = format_output(f"SQLMap SQL Injection Test: {target}", output, returncode)
        
        cache_result(cache_key, result)
        log_audit_event("sqlmap", target, returncode == 0, f"has_data: {bool(data)}")
        
        return result
        
    except ValueError as e:
        log_audit_event("sqlmap", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"SQLMap error: {e}", exc_info=True)
        log_audit_event("sqlmap", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def searchsploit_query(keyword: str = "") -> str:
    """
    Search exploit database using searchsploit for known vulnerabilities.
    
    Args:
        keyword: Search term (e.g., 'apache 2.4', 'wordpress 5.0')
    
    Returns:
        List of known exploits matching the keyword
    """
    if not keyword.strip():
        return "ERROR: Search keyword is required (e.g., 'apache 2.4', 'wordpress 5.0')"
    
    if not check_rate_limit("searchsploit"):
        return "ERROR: Rate limit exceeded. Maximum 10 searches per hour."
    
    try:
        # Basic sanitization
        keyword = keyword.strip()
        if len(keyword) > 100:
            raise ValueError("Keyword too long (max 100 characters)")
        
        if any(c in keyword for c in [';', '|', '&', '`', '$']):
            raise ValueError("Invalid characters in keyword")
        
        logger.info(f"Searching exploits for: {keyword}")
        command = ["searchsploit", keyword]
        output, returncode = run_command(command, timeout=60)
        
        log_audit_event("searchsploit", keyword, returncode == 0, "")
        
        return format_output(f"Exploit Database Search: {keyword}", output, returncode)
        
    except ValueError as e:
        log_audit_event("searchsploit", keyword, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Searchsploit error: {e}", exc_info=True)
        log_audit_event("searchsploit", keyword, False, f"exception: {str(e)}")
        return f"ERROR: Search failed - {str(e)}"


@mcp.tool()
async def quick_recon(target: str = "") -> str:
    """
    Perform quick reconnaissance combining fast nmap scan.
    
    Args:
        target: IP address or domain (e.g., 'scanme.nmap.org')
    
    Returns:
        Quick reconnaissance results
    """
    if not target.strip():
        return "ERROR: Target is required (e.g., 'scanme.nmap.org' or '8.8.8.8')"
    
    if not check_rate_limit("quick_recon"):
        return "ERROR: Rate limit exceeded. Maximum 10 scans per hour."
    
    try:
        target = validate_target(target, "ip")
        
        logger.info(f"Running quick recon on {target}")
        
        command = ["nmap", "-F", "-sV", target]
        output, returncode = run_command(command, timeout=300)
        
        result = f"Quick Reconnaissance Results\n{'=' * 60}\n\nTarget: {target}\n\n{output}"
        
        log_audit_event("quick_recon", target, returncode == 0, "")
        
        return result
        
    except ValueError as e:
        log_audit_event("quick_recon", target, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Quick recon error: {e}", exc_info=True)
        log_audit_event("quick_recon", target, False, f"exception: {str(e)}")
        return f"ERROR: Scan failed - {str(e)}"


@mcp.tool()
async def apt_install(package: str = "") -> str:
    """
    Install a package using apt package manager.
    
    Args:
        package: Package name (e.g., 'metasploit-framework', 'burpsuite')
    
    Returns:
        Installation result
    """
    if not package.strip():
        return "ERROR: Package name is required (e.g., 'metasploit-framework')"
    
    try:
        # Validate package name (alphanumeric, dash, underscore only)
        if not re.match(r'^[a-zA-Z0-9_-]+$', package):
            raise ValueError("Invalid package name. Use only letters, numbers, dash, and underscore")
        
        if len(package) > 100:
            raise ValueError("Package name too long")
        
        logger.info(f"Installing package: {package}")
        
        # Update package list
        update_cmd = ["apt-get", "update"]
        update_output, update_ret = run_command(update_cmd, timeout=120)
        
        if update_ret != 0:
            return f"ERROR: Failed to update package list:\n{update_output}"
        
        # Install package
        install_cmd = ["apt-get", "install", "-y", package]
        install_output, install_ret = run_command(install_cmd, timeout=600)
        
        log_audit_event("apt_install", package, install_ret == 0, "")
        
        if install_ret == 0:
            return f"SUCCESS - Package Installed\n\nPackage '{package}' has been successfully installed.\n\n{install_output}"
        else:
            return f"ERROR: Failed to install package '{package}':\n{install_output}"
            
    except ValueError as e:
        log_audit_event("apt_install", package, False, str(e))
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Apt install error: {e}", exc_info=True)
        log_audit_event("apt_install", package, False, f"exception: {str(e)}")
        return f"ERROR: Installation failed - {str(e)}"


@mcp.tool()
async def apt_search(keyword: str = "") -> str:
    """
    Search for available packages in apt repositories.
    
    Args:
        keyword: Search term (e.g., 'wireless', 'web scanner')
    
    Returns:
        List of matching packages
    """
    if not keyword.strip():
        return "ERROR: Search keyword is required"
    
    try:
        keyword = keyword.strip()
        if len(keyword) > 100:
            raise ValueError("Keyword too long")
        
        if not re.match(r'^[a-zA-Z0-9 _-]+$', keyword):
            raise ValueError("Invalid characters in keyword")
        
        logger.info(f"Searching for packages matching: {keyword}")
        command = ["apt-cache", "search", keyword]
        output, returncode = run_command(command, timeout=60)
        
        return format_output(f"Package Search Results: {keyword}", output, returncode)
        
    except ValueError as e:
        return f"ERROR: {str(e)}"
    except Exception as e:
        logger.error(f"Apt search error: {e}", exc_info=True)
        return f"ERROR: Search failed - {str(e)}"


@mcp.tool()
async def git_clone(repo_url: str = "", destination: str = "") -> str:
    """
    Clone a git repository to the specified destination.
    
    Args:
        repo_url: Git repository URL (e.g., 'https://github.com/user/repo.git')
        destination: Target directory (optional)
    
    Returns:
        Clone operation result
    """
    if not repo_url.strip():
        return "ERROR: Repository URL is required (e.g., 'https://github.com/user/repo.git')"
    
    try:
        repo_url = repo_url.strip()
        
        # Validate URL format
        if not re.match(r'^https?://[a-zA-Z0-9][a-zA-Z0-9-_.:/]*[a-zA-Z0-9]/?.*\.git$', repo_url):
            raise ValueError("Invalid Git repository URL format (must be https:// or http:// and end with .git)")
        
        logger.info(f"Cloning repository: {repo_url}")
        
        command = ["git", "clone", repo_url]
        
        if destination.strip():
            # Validate destination path
            if not re.match(r'^[a-zA-Z0-9_/-]+$', destination):
                raise ValueError("Invalid destination path")
            command.append(destination)
        
        output, returncode = run_
